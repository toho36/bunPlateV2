---
alwaysApply: true
---

# Hooks Organization and Conventions

## Overview

This document defines the comprehensive structure, patterns, and conventions for React hooks in the GameOne event management system. All hooks should follow consistent patterns for state management, data fetching, side effects, and component lifecycle management.

## Directory Structure

```
src/hooks/
├── core/                   # Core system hooks
│   ├── use-auth.ts        # Authentication state and operations
│   ├── use-config.ts      # Application configuration
│   ├── use-logger.ts      # Logging functionality
│   ├── use-permissions.ts # Permission checking
│   └── use-locale.ts      # Internationalization
├── data/                  # Data fetching and management hooks
│   ├── use-query.ts       # Generic query hook
│   ├── use-mutation.ts    # Generic mutation hook
│   ├── use-pagination.ts  # Pagination state management
│   ├── use-infinite-query.ts # Infinite scrolling queries
│   └── use-optimistic.ts  # Optimistic updates
├── features/              # Feature-specific hooks
│   ├── events/
│   │   ├── use-events.ts
│   │   ├── use-event.ts
│   │   ├── use-event-registration.ts
│   │   ├── use-event-feedback.ts
│   │   └── index.ts
│   ├── users/
│   │   ├── use-users.ts
│   │   ├── use-user-profile.ts
│   │   ├── use-user-roles.ts
│   │   └── index.ts
│   ├── registration/
│   │   ├── use-registration.ts
│   │   ├── use-waiting-list.ts
│   │   ├── use-registration-wizard.ts
│   │   └── index.ts
│   ├── payments/
│   │   ├── use-payments.ts
│   │   ├── use-payment-methods.ts
│   │   ├── use-qr-code.ts
│   │   └── index.ts
│   └── videos/
│       ├── use-videos.ts
│       ├── use-video-reactions.ts
│       └── index.ts
├── ui/                    # UI and interaction hooks
│   ├── use-toast.ts       # Toast notifications
│   ├── use-modal.ts       # Modal state management
│   ├── use-dropdown.ts    # Dropdown state
│   ├── use-tabs.ts        # Tab navigation
│   ├── use-search.ts      # Search functionality
│   ├── use-filters.ts     # Filter state management
│   ├── use-form.ts        # Form state and validation
│   └── use-clipboard.ts   # Clipboard operations
├── utilities/             # Utility hooks
│   ├── use-debounce.ts    # Debouncing
│   ├── use-throttle.ts    # Throttling
│   ├── use-local-storage.ts # Local storage persistence
│   ├── use-session-storage.ts # Session storage
│   ├── use-media-query.ts # Responsive design
│   ├── use-intersection.ts # Intersection observer
│   ├── use-click-outside.ts # Click outside detection
│   ├── use-keyboard.ts    # Keyboard shortcuts
│   ├── use-async.ts       # Async operation state
│   └── use-previous.ts    # Previous value tracking
├── effects/               # Side effect hooks
│   ├── use-document-title.ts # Document title management
│   ├── use-focus-trap.ts  # Focus management
│   ├── use-scroll-lock.ts # Scroll locking
│   ├── use-event-listener.ts # Event listeners
│   ├── use-interval.ts    # Intervals
│   ├── use-timeout.ts     # Timeouts
│   └── use-websocket.ts   # WebSocket connections
└── performance/           # Performance optimization hooks
    ├── use-memo-deep.ts   # Deep memoization
    ├── use-callback-ref.ts # Callback refs
    ├── use-lazy-ref.ts    # Lazy initialization
    └── use-virtual-list.ts # Virtual scrolling
```

## Hook Naming Conventions

### General Rules

- **Prefix**: All hooks must start with `use` (React convention)
- **Naming**: Use camelCase (e.g., `useEventRegistration`, `useUserProfile`)
- **Descriptive**: Names should clearly indicate the hook's purpose
- **Consistent**: Use consistent naming patterns across similar hooks

### Specific Patterns

- **Data fetching**: `use{Resource}` or `use{Resource}s` (e.g., `useEvent`, `useEvents`)
- **State management**: `use{State}State` (e.g., `useModalState`, `useFormState`)
- **Operations**: `use{Action}` (e.g., `useCreateEvent`, `useUpdateUser`)
- **Utilities**: `use{Utility}` (e.g., `useDebounce`, `useLocalStorage`)

## Core System Hooks

### Authentication Hook (`src/hooks/core/use-auth.ts`)

```typescript
import { useContext, createContext, useState, useEffect, useCallback } from 'react';
import { User } from '@prisma/client';

interface AuthContextValue {
  user: User | null;
  loading: boolean;
  error: string | null;
  isAuthenticated: boolean;
  login: (credentials: LoginCredentials) => Promise<void>;
  logout: () => Promise<void>;
  refreshToken: () => Promise<void>;
  hasPermission: (permission: string) => boolean;
  hasRole: (role: string) => boolean;
}

const AuthContext = createContext<AuthContextValue | undefined>(undefined);

export function useAuth(): AuthContextValue {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
}

// Provider component (would be in providers directory)
export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const login = useCallback(async (credentials: LoginCredentials) => {
    try {
      setLoading(true);
      setError(null);

      const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(credentials)
      });

      if (!response.ok) {
        throw new Error('Login failed');
      }

      const { user } = await response.json();
      setUser(user);
    } catch (error) {
      setError(error instanceof Error ? error.message : 'Login failed');
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  const logout = useCallback(async () => {
    try {
      await fetch('/api/auth/logout', { method: 'POST' });
      setUser(null);
    } catch (error) {
      console.error('Logout error:', error);
    }
  }, []);

  const refreshToken = useCallback(async () => {
    try {
      const response = await fetch('/api/auth/refresh', { method: 'POST' });
      if (response.ok) {
        const { user } = await response.json();
        setUser(user);
      }
    } catch (error) {
      console.error('Token refresh error:', error);
    }
  }, []);

  const hasPermission = useCallback((permission: string): boolean => {
    if (!user) return false;
    // Implementation depends on your permission system
    return user.permissions?.includes(permission) || false;
  }, [user]);

  const hasRole = useCallback((role: string): boolean => {
    if (!user) return false;
    return user.roles?.some(r => r.name === role) || false;
  }, [user]);

  useEffect(() => {
    // Initialize auth state on mount
    const initAuth = async () => {
      try {
        const response = await fetch('/api/auth/me');
        if (response.ok) {
          const { user } = await response.json();
          setUser(user);
        }
      } catch (error) {
        console.error('Auth initialization error:', error);
      } finally {
        setLoading(false);
      }
    };

    initAuth();
  }, []);

  const value: AuthContextValue = {
    user,
    loading,
    error,
    isAuthenticated: !!user,
    login,
    logout,
    refreshToken,
    hasPermission,
    hasRole
  };

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
}
```

### Generic Query Hook (`src/hooks/data/use-query.ts`)

```typescript
import { useState, useEffect, useCallback, useRef } from 'react';

export interface QueryOptions<T> {
  queryKey: string[];
  queryFn: () => Promise<T>;
  enabled?: boolean;
  staleTime?: number;
  cacheTime?: number;
  refetchOnWindowFocus?: boolean;
  refetchInterval?: number;
  retry?: number;
  retryDelay?: (attempt: number) => number;
  onSuccess?: (data: T) => void;
  onError?: (error: Error) => void;
}

export interface QueryResult<T> {
  data: T | undefined;
  loading: boolean;
  error: Error | null;
  refetch: () => Promise<void>;
  isStale: boolean;
  isFetching: boolean;
}

// Simple in-memory cache
const queryCache = new Map<string, {
  data: any;
  timestamp: number;
  staleTime: number;
}>();

export function useQuery<T>(options: QueryOptions<T>): QueryResult<T> {
  const {
    queryKey,
    queryFn,
    enabled = true,
    staleTime = 5 * 60 * 1000, // 5 minutes
    cacheTime = 10 * 60 * 1000, // 10 minutes
    refetchOnWindowFocus = true,
    refetchInterval,
    retry = 3,
    retryDelay = (attempt) => Math.pow(2, attempt) * 1000,
    onSuccess,
    onError
  } = options;

  const [data, setData] = useState<T | undefined>(undefined);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  const [isFetching, setIsFetching] = useState(false);

  const cacheKey = JSON.stringify(queryKey);
  const abortControllerRef = useRef<AbortController | null>(null);
  const retryCountRef = useRef(0);

  const getCachedData = useCallback(() => {
    const cached = queryCache.get(cacheKey);
    if (!cached) return null;

    const isExpired = Date.now() - cached.timestamp > cacheTime;
    if (isExpired) {
      queryCache.delete(cacheKey);
      return null;
    }

    return cached;
  }, [cacheKey, cacheTime]);

  const isStale = useCallback(() => {
    const cached = getCachedData();
    if (!cached) return true;
    return Date.now() - cached.timestamp > cached.staleTime;
  }, [getCachedData]);

  const fetchData = useCallback(async () => {
    if (!enabled) return;

    // Cancel previous request
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }

    // Check cache first
    const cached = getCachedData();
    if (cached && !isStale()) {
      setData(cached.data);
      setError(null);
      return;
    }

    setIsFetching(true);
    if (!data) setLoading(true);

    abortControllerRef.current = new AbortController();

    try {
      const result = await queryFn();

      // Cache the result
      queryCache.set(cacheKey, {
        data: result,
        timestamp: Date.now(),
        staleTime
      });

      setData(result);
      setError(null);
      retryCountRef.current = 0;
      onSuccess?.(result);
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));

      if (error.name === 'AbortError') return;

      if (retryCountRef.current < retry) {
        retryCountRef.current++;
        const delay = retryDelay(retryCountRef.current);
        setTimeout(() => fetchData(), delay);
        return;
      }

      setError(error);
      onError?.(error);
    } finally {
      setLoading(false);
      setIsFetching(false);
    }
  }, [enabled, queryFn, getCachedData, isStale, data, cacheKey, staleTime, retry, retryDelay, onSuccess, onError]);

  // Initial fetch
  useEffect(() => {
    fetchData();
  }, [fetchData]);

  // Refetch interval
  useEffect(() => {
    if (!refetchInterval || !enabled) return;

    const interval = setInterval(fetchData, refetchInterval);
    return () => clearInterval(interval);
  }, [refetchInterval, enabled, fetchData]);

  // Refetch on window focus
  useEffect(() => {
    if (!refetchOnWindowFocus || !enabled) return;

    const handleFocus = () => {
      if (isStale()) {
        fetchData();
      }
    };

    window.addEventListener('focus', handleFocus);
    return () => window.removeEventListener('focus', handleFocus);
  }, [refetchOnWindowFocus, enabled, isStale, fetchData]);

  // Cleanup
  useEffect(() => {
    return () => {
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
      }
    };
  }, []);

  return {
    data,
    loading,
    error,
    refetch: fetchData,
    isStale: isStale(),
    isFetching
  };
}
```

## Feature-Specific Hooks

### Event Management Hook (`src/hooks/features/events/use-events.ts`)

```typescript
import { useMemo } from 'react';
import { useQuery } from '@/hooks/data/use-query';
import { usePagination } from '@/hooks/data/use-pagination';
import type { Event } from '@prisma/client';

export interface EventFilters {
  status?: string;
  categoryId?: string;
  startDate?: Date;
  endDate?: Date;
  search?: string;
  tags?: string[];
}

export interface UseEventsOptions {
  filters?: EventFilters;
  sort?: {
    field: string;
    order: 'asc' | 'desc';
  };
  enabled?: boolean;
}

export interface UseEventsResult {
  events: Event[];
  loading: boolean;
  error: Error | null;
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
    hasNext: boolean;
    hasPrev: boolean;
    goToPage: (page: number) => void;
    nextPage: () => void;
    prevPage: () => void;
  };
  filters: EventFilters;
  setFilters: (filters: EventFilters) => void;
  sort: { field: string; order: 'asc' | 'desc' };
  setSort: (field: string, order?: 'asc' | 'desc') => void;
  refetch: () => Promise<void>;
}

export function useEvents(options: UseEventsOptions = {}): UseEventsResult {
  const { filters = {}, sort = { field: 'startDate', order: 'desc' }, enabled = true } = options;

  const pagination = usePagination({ pageSize: 20 });

  // Build query parameters
  const queryParams = useMemo(() => {
    const params = new URLSearchParams({
      page: pagination.page.toString(),
      limit: pagination.limit.toString(),
      sortBy: sort.field,
      sortOrder: sort.order
    });

    Object.entries(filters).forEach(([key, value]) => {
      if (value !== undefined && value !== null && value !== '') {
        if (Array.isArray(value)) {
          value.forEach(v => params.append(key, v));
        } else if (value instanceof Date) {
          params.append(key, value.toISOString());
        } else {
          params.append(key, String(value));
        }
      }
    });

    return params.toString();
  }, [filters, sort, pagination.page, pagination.limit]);

  // Fetch events
  const {
    data: response,
    loading,
    error,
    refetch
  } = useQuery({
    queryKey: ['events', queryParams],
    queryFn: async () => {
      const response = await fetch(`/api/events?${queryParams}`);
      if (!response.ok) {
        throw new Error('Failed to fetch events');
      }
      return response.json();
    },
    enabled,
    staleTime: 2 * 60 * 1000, // 2 minutes
    onSuccess: (data) => {
      pagination.setTotal(data.pagination.total);
    }
  });

  const events = response?.data || [];

  const setFilters = useMemo(() => {
    return (newFilters: EventFilters) => {
      // Reset to first page when filters change
      pagination.goToPage(1);
      // Trigger refetch with new filters
      refetch();
    };
  }, [pagination, refetch]);

  const setSort = useMemo(() => {
    return (field: string, order: 'asc' | 'desc' = 'desc') => {
      // Sort change should trigger refetch
      refetch();
    };
  }, [refetch]);

  return {
    events,
    loading,
    error,
    pagination: {
      page: pagination.page,
      limit: pagination.limit,
      total: pagination.total,
      totalPages: pagination.totalPages,
      hasNext: pagination.hasNext,
      hasPrev: pagination.hasPrev,
      goToPage: pagination.goToPage,
      nextPage: pagination.nextPage,
      prevPage: pagination.prevPage
    },
    filters,
    setFilters,
    sort,
    setSort,
    refetch
  };
}
```

### Form Management Hook (`src/hooks/ui/use-form.ts`)

```typescript
import { useState, useCallback, useRef } from 'react';
import { z } from 'zod';

export interface FormField<T = any> {
  value: T;
  error: string | null;
  touched: boolean;
  dirty: boolean;
}

export interface FormState<T extends Record<string, any>> {
  fields: { [K in keyof T]: FormField<T[K]> };
  isValid: boolean;
  isDirty: boolean;
  isSubmitting: boolean;
  errors: Partial<Record<keyof T, string>>;
}

export interface UseFormOptions<T extends Record<string, any>> {
  initialValues: T;
  validationSchema?: z.ZodSchema<T>;
  validateOnChange?: boolean;
  validateOnBlur?: boolean;
  onSubmit?: (values: T) => Promise<void> | void;
}

export interface UseFormResult<T extends Record<string, any>> {
  values: T;
  errors: Partial<Record<keyof T, string>>;
  touched: Partial<Record<keyof T, boolean>>;
  isValid: boolean;
  isDirty: boolean;
  isSubmitting: boolean;
  setValue: <K extends keyof T>(field: K, value: T[K]) => void;
  setFieldError: <K extends keyof T>(field: K, error: string | null) => void;
  setFieldTouched: <K extends keyof T>(field: K, touched?: boolean) => void;
  validateField: <K extends keyof T>(field: K) => Promise<boolean>;
  validateForm: () => Promise<boolean>;
  resetForm: (values?: Partial<T>) => void;
  resetField: <K extends keyof T>(field: K) => void;
  handleSubmit: (e?: React.FormEvent) => Promise<void>;
  getFieldProps: <K extends keyof T>(field: K) => {
    value: T[K];
    onChange: (value: T[K]) => void;
    onBlur: () => void;
    error: string | null;
    touched: boolean;
  };
}

export function useForm<T extends Record<string, any>>(
  options: UseFormOptions<T>
): UseFormResult<T> {
  const {
    initialValues,
    validationSchema,
    validateOnChange = true,
    validateOnBlur = true,
    onSubmit
  } = options;

  // Form state
  const [values, setValues] = useState<T>(initialValues);
  const [errors, setErrors] = useState<Partial<Record<keyof T, string>>>({});
  const [touched, setTouched] = useState<Partial<Record<keyof T, boolean>>>({});
  const [isSubmitting, setIsSubmitting] = useState(false);

  const initialValuesRef = useRef(initialValues);

  // Computed properties
  const isValid = Object.keys(errors).length === 0;
  const isDirty = JSON.stringify(values) !== JSON.stringify(initialValuesRef.current);

  // Set field value
  const setValue = useCallback(<K extends keyof T>(field: K, value: T[K]) => {
    setValues(prev => ({ ...prev, [field]: value }));

    if (validateOnChange) {
      validateField(field);
    }
  }, [validateOnChange]);

  // Set field error
  const setFieldError = useCallback(<K extends keyof T>(field: K, error: string | null) => {
    setErrors(prev => {
      if (error === null) {
        const { [field]: _, ...rest } = prev;
        return rest;
      }
      return { ...prev, [field]: error };
    });
  }, []);

  // Set field touched
  const setFieldTouched = useCallback(<K extends keyof T>(
    field: K,
    touchedValue: boolean = true
  ) => {
    setTouched(prev => ({ ...prev, [field]: touchedValue }));

    if (touchedValue && validateOnBlur) {
      validateField(field);
    }
  }, [validateOnBlur]);

  // Validate single field
  const validateField = useCallback(async <K extends keyof T>(field: K): Promise<boolean> => {
    if (!validationSchema) return true;

    try {
      const fieldSchema = validationSchema.shape?.[field as string];
      if (fieldSchema) {
        await fieldSchema.parseAsync(values[field]);
        setFieldError(field, null);
        return true;
      }
    } catch (error) {
      if (error instanceof z.ZodError) {
        const fieldError = error.errors[0]?.message || 'Invalid value';
        setFieldError(field, fieldError);
        return false;
      }
    }

    return true;
  }, [validationSchema, values, setFieldError]);

  // Validate entire form
  const validateForm = useCallback(async (): Promise<boolean> => {
    if (!validationSchema) return true;

    try {
      await validationSchema.parseAsync(values);
      setErrors({});
      return true;
    } catch (error) {
      if (error instanceof z.ZodError) {
        const formErrors: Partial<Record<keyof T, string>> = {};
        error.errors.forEach(err => {
          const field = err.path[0] as keyof T;
          if (field) {
            formErrors[field] = err.message;
          }
        });
        setErrors(formErrors);
        return false;
      }
    }

    return false;
  }, [validationSchema, values]);

  // Reset form
  const resetForm = useCallback((newValues?: Partial<T>) => {
    const resetValues = { ...initialValues, ...newValues };
    setValues(resetValues);
    setErrors({});
    setTouched({});
    setIsSubmitting(false);
    initialValuesRef.current = resetValues;
  }, [initialValues]);

  // Reset single field
  const resetField = useCallback(<K extends keyof T>(field: K) => {
    setValues(prev => ({ ...prev, [field]: initialValues[field] }));
    setFieldError(field, null);
    setFieldTouched(field, false);
  }, [initialValues, setFieldError, setFieldTouched]);

  // Handle form submission
  const handleSubmit = useCallback(async (e?: React.FormEvent) => {
    e?.preventDefault();

    if (isSubmitting) return;

    setIsSubmitting(true);

    try {
      const isFormValid = await validateForm();

      if (isFormValid && onSubmit) {
        await onSubmit(values);
      }
    } catch (error) {
      console.error('Form submission error:', error);
    } finally {
      setIsSubmitting(false);
    }
  }, [isSubmitting, validateForm, onSubmit, values]);

  // Get field props for easy integration
  const getFieldProps = useCallback(<K extends keyof T>(field: K) => ({
    value: values[field],
    onChange: (value: T[K]) => setValue(field, value),
    onBlur: () => setFieldTouched(field, true),
    error: errors[field] || null,
    touched: touched[field] || false
  }), [values, errors, touched, setValue, setFieldTouched]);

  return {
    values,
    errors,
    touched,
    isValid,
    isDirty,
    isSubmitting,
    setValue,
    setFieldError,
    setFieldTouched,
    validateField,
    validateForm,
    resetForm,
    resetField,
    handleSubmit,
    getFieldProps
  };
}
```

## Utility Hooks

### Local Storage Hook (`src/hooks/utilities/use-local-storage.ts`)

```typescript
import { useState, useEffect, useCallback } from 'react';

export function useLocalStorage<T>(
  key: string,
  initialValue: T
): [T, (value: T | ((prev: T) => T)) => void, () => void] {
  // Get value from localStorage or use initial value
  const [storedValue, setStoredValue] = useState<T>(() => {
    if (typeof window === 'undefined') {
      return initialValue;
    }

    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(`Error reading localStorage key "${key}":`, error);
      return initialValue;
    }
  });

  // Update localStorage when state changes
  const setValue = useCallback((value: T | ((prev: T) => T)) => {
    try {
      const valueToStore = value instanceof Function ? value(storedValue) : value;
      setStoredValue(valueToStore);

      if (typeof window !== 'undefined') {
        window.localStorage.setItem(key, JSON.stringify(valueToStore));
      }
    } catch (error) {
      console.error(`Error setting localStorage key "${key}":`, error);
    }
  }, [key, storedValue]);

  // Remove item from localStorage
  const removeValue = useCallback(() => {
    try {
      setStoredValue(initialValue);
      if (typeof window !== 'undefined') {
        window.localStorage.removeItem(key);
      }
    } catch (error) {
      console.error(`Error removing localStorage key "${key}":`, error);
    }
  }, [key, initialValue]);

  // Listen for changes from other tabs/windows
  useEffect(() => {
    if (typeof window === 'undefined') return;

    const handleStorageChange = (e: StorageEvent) => {
      if (e.key === key && e.newValue !== null) {
        try {
          setStoredValue(JSON.parse(e.newValue));
        } catch (error) {
          console.error(`Error parsing localStorage value for key "${key}":`, error);
        }
      }
    };

    window.addEventListener('storage', handleStorageChange);
    return () => window.removeEventListener('storage', handleStorageChange);
  }, [key]);

  return [storedValue, setValue, removeValue];
}
```

### Debounce Hook (`src/hooks/utilities/use-debounce.ts`)

```typescript
import { useState, useEffect, useRef } from 'react';

export function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}

export function useDebouncedCallback<T extends (...args: any[]) => any>(
  callback: T,
  delay: number
): T {
  const callbackRef = useRef(callback);
  const timeoutRef = useRef<NodeJS.Timeout>();

  // Update callback ref when callback changes
  useEffect(() => {
    callbackRef.current = callback;
  }, [callback]);

  const debouncedCallback = useRef(
    ((...args: Parameters<T>) => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }

      timeoutRef.current = setTimeout(() => {
        callbackRef.current(...args);
      }, delay);
    }) as T
  );

  // Cleanup timeout on unmount
  useEffect(() => {
    return () => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
    };
  }, []);

  return debouncedCallback.current;
}
```

## Performance Hooks

### Memoization Hook (`src/hooks/performance/use-memo-deep.ts`)

```typescript
import { useRef, useMemo } from 'react';

// Deep equality check
function deepEqual(a: any, b: any): boolean {
  if (a === b) return true;

  if (a == null || b == null) return a === b;

  if (typeof a !== typeof b) return false;

  if (typeof a !== 'object') return a === b;

  if (Array.isArray(a) !== Array.isArray(b)) return false;

  if (Array.isArray(a)) {
    if (a.length !== b.length) return false;
    for (let i = 0; i < a.length; i++) {
      if (!deepEqual(a[i], b[i])) return false;
    }
    return true;
  }

  const keysA = Object.keys(a);
  const keysB = Object.keys(b);

  if (keysA.length !== keysB.length) return false;

  for (let key of keysA) {
    if (!keysB.includes(key)) return false;
    if (!deepEqual(a[key], b[key])) return false;
  }

  return true;
}

export function useMemoDeep<T>(factory: () => T, deps: React.DependencyList): T {
  const ref = useRef<{ deps: React.DependencyList; value: T }>();

  return useMemo(() => {
    if (!ref.current || !deepEqual(ref.current.deps, deps)) {
      ref.current = {
        deps,
        value: factory()
      };
    }
    return ref.current.value;
  }, deps);
}
```

## Hook Testing Patterns

### Hook Testing Utilities (`src/hooks/__tests__/test-utils.ts`)

```typescript
import { renderHook, RenderHookResult } from '@testing-library/react';
import { act } from '@testing-library/react';

// Wrapper for testing hooks with providers
export function renderHookWithProviders<TProps, TResult>(
  hook: (props: TProps) => TResult,
  options?: {
    initialProps?: TProps;
    wrapper?: React.ComponentType;
  }
): RenderHookResult<TResult, TProps> {
  return renderHook(hook, options);
}

// Async hook testing utility
export async function actAsync(fn: () => Promise<any>): Promise<void> {
  await act(async () => {
    await fn();
  });
}

// Mock localStorage for testing
export function mockLocalStorage() {
  const storage: Record<string, string> = {};

  const mockLocalStorage = {
    getItem: jest.fn((key: string) => storage[key] || null),
    setItem: jest.fn((key: string, value: string) => {
      storage[key] = value;
    }),
    removeItem: jest.fn((key: string) => {
      delete storage[key];
    }),
    clear: jest.fn(() => {
      Object.keys(storage).forEach(key => delete storage[key]);
    }),
    length: 0,
    key: jest.fn()
  };

  Object.defineProperty(window, 'localStorage', {
    value: mockLocalStorage,
    writable: true
  });

  return mockLocalStorage;
}
```

### Hook Test Example

```typescript
// __tests__/use-events.test.ts
import { renderHook, waitFor } from '@testing-library/react';
import { useEvents } from '@/hooks/features/events/use-events';
import { mockLocalStorage } from './test-utils';

// Mock fetch
global.fetch = jest.fn();

describe('useEvents', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    mockLocalStorage();
  });

  it('should fetch events on mount', async () => {
    const mockEvents = [
      { id: '1', title: 'Event 1', startDate: new Date() },
      { id: '2', title: 'Event 2', startDate: new Date() }
    ];

    (fetch as jest.Mock).mockResolvedValue({
      ok: true,
      json: async () => ({
        data: mockEvents,
        pagination: { total: 2, page: 1, limit: 20 }
      })
    });

    const { result } = renderHook(() => useEvents());

    expect(result.current.loading).toBe(true);

    await waitFor(() => {
      expect(result.current.loading).toBe(false);
    });

    expect(result.current.events).toEqual(mockEvents);
    expect(result.current.error).toBeNull();
  });

  it('should handle fetch errors', async () => {
    (fetch as jest.Mock).mockRejectedValue(new Error('Fetch failed'));

    const { result } = renderHook(() => useEvents());

    await waitFor(() => {
      expect(result.current.loading).toBe(false);
    });

    expect(result.current.error).toEqual(new Error('Fetch failed'));
    expect(result.current.events).toEqual([]);
  });
});
```

## Documentation Requirements

### Hook Documentation

````typescript
/**
 * Hook for managing event data with filtering, sorting, and pagination.
 *
 * @param options - Configuration options for the hook
 * @returns Object containing events data, loading state, and control functions
 *
 * @example
 * ```tsx
 * function EventList() {
 *   const { events, loading, setFilters } = useEvents({
 *     filters: { status: 'published' },
 *     sort: { field: 'startDate', order: 'asc' }
 *   });
 *
 *   if (loading) return <Loading />;
 *
 *   return (
 *     <div>
 *       {events.map(event => (
 *         <EventCard key={event.id} event={event} />
 *       ))}
 *     </div>
 *   );
 * }
 * ```
 */
export function useEvents(options: UseEventsOptions = {}): UseEventsResult {
  // Implementation
}
````

This comprehensive hook organization provides a solid foundation for building maintainable, reusable, and well-tested React hooks in the GameOne application.# Hooks Organization and Conventions

## Overview

This document defines the comprehensive structure, patterns, and conventions for React hooks in the GameOne event management system. All hooks should follow consistent patterns for state management, data fetching, side effects, and component lifecycle management.

## Directory Structure

```
src/hooks/
├── core/                   # Core system hooks
│   ├── use-auth.ts        # Authentication state and operations
│   ├── use-config.ts      # Application configuration
│   ├── use-logger.ts      # Logging functionality
│   ├── use-permissions.ts # Permission checking
│   └── use-locale.ts      # Internationalization
├── data/                  # Data fetching and management hooks
│   ├── use-query.ts       # Generic query hook
│   ├── use-mutation.ts    # Generic mutation hook
│   ├── use-pagination.ts  # Pagination state management
│   ├── use-infinite-query.ts # Infinite scrolling queries
│   └── use-optimistic.ts  # Optimistic updates
├── features/              # Feature-specific hooks
│   ├── events/
│   │   ├── use-events.ts
│   │   ├── use-event.ts
│   │   ├── use-event-registration.ts
│   │   ├── use-event-feedback.ts
│   │   └── index.ts
│   ├── users/
│   │   ├── use-users.ts
│   │   ├── use-user-profile.ts
│   │   ├── use-user-roles.ts
│   │   └── index.ts
│   ├── registration/
│   │   ├── use-registration.ts
│   │   ├── use-waiting-list.ts
│   │   ├── use-registration-wizard.ts
│   │   └── index.ts
│   ├── payments/
│   │   ├── use-payments.ts
│   │   ├── use-payment-methods.ts
│   │   ├── use-qr-code.ts
│   │   └── index.ts
│   └── videos/
│       ├── use-videos.ts
│       ├── use-video-reactions.ts
│       └── index.ts
├── ui/                    # UI and interaction hooks
│   ├── use-toast.ts       # Toast notifications
│   ├── use-modal.ts       # Modal state management
│   ├── use-dropdown.ts    # Dropdown state
│   ├── use-tabs.ts        # Tab navigation
│   ├── use-search.ts      # Search functionality
│   ├── use-filters.ts     # Filter state management
│   ├── use-form.ts        # Form state and validation
│   └── use-clipboard.ts   # Clipboard operations
├── utilities/             # Utility hooks
│   ├── use-debounce.ts    # Debouncing
│   ├── use-throttle.ts    # Throttling
│   ├── use-local-storage.ts # Local storage persistence
│   ├── use-session-storage.ts # Session storage
│   ├── use-media-query.ts # Responsive design
│   ├── use-intersection.ts # Intersection observer
│   ├── use-click-outside.ts # Click outside detection
│   ├── use-keyboard.ts    # Keyboard shortcuts
│   ├── use-async.ts       # Async operation state
│   └── use-previous.ts    # Previous value tracking
├── effects/               # Side effect hooks
│   ├── use-document-title.ts # Document title management
│   ├── use-focus-trap.ts  # Focus management
│   ├── use-scroll-lock.ts # Scroll locking
│   ├── use-event-listener.ts # Event listeners
│   ├── use-interval.ts    # Intervals
│   ├── use-timeout.ts     # Timeouts
│   └── use-websocket.ts   # WebSocket connections
└── performance/           # Performance optimization hooks
    ├── use-memo-deep.ts   # Deep memoization
    ├── use-callback-ref.ts # Callback refs
    ├── use-lazy-ref.ts    # Lazy initialization
    └── use-virtual-list.ts # Virtual scrolling
```

## Hook Naming Conventions

### General Rules

- **Prefix**: All hooks must start with `use` (React convention)
- **Naming**: Use camelCase (e.g., `useEventRegistration`, `useUserProfile`)
- **Descriptive**: Names should clearly indicate the hook's purpose
- **Consistent**: Use consistent naming patterns across similar hooks

### Specific Patterns

- **Data fetching**: `use{Resource}` or `use{Resource}s` (e.g., `useEvent`, `useEvents`)
- **State management**: `use{State}State` (e.g., `useModalState`, `useFormState`)
- **Operations**: `use{Action}` (e.g., `useCreateEvent`, `useUpdateUser`)
- **Utilities**: `use{Utility}` (e.g., `useDebounce`, `useLocalStorage`)

## Core System Hooks

### Authentication Hook (`src/hooks/core/use-auth.ts`)

```typescript
import { useContext, createContext, useState, useEffect, useCallback } from 'react';
import { User } from '@prisma/client';

interface AuthContextValue {
  user: User | null;
  loading: boolean;
  error: string | null;
  isAuthenticated: boolean;
  login: (credentials: LoginCredentials) => Promise<void>;
  logout: () => Promise<void>;
  refreshToken: () => Promise<void>;
  hasPermission: (permission: string) => boolean;
  hasRole: (role: string) => boolean;
}

const AuthContext = createContext<AuthContextValue | undefined>(undefined);

export function useAuth(): AuthContextValue {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
}

// Provider component (would be in providers directory)
export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const login = useCallback(async (credentials: LoginCredentials) => {
    try {
      setLoading(true);
      setError(null);

      const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(credentials)
      });

      if (!response.ok) {
        throw new Error('Login failed');
      }

      const { user } = await response.json();
      setUser(user);
    } catch (error) {
      setError(error instanceof Error ? error.message : 'Login failed');
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  const logout = useCallback(async () => {
    try {
      await fetch('/api/auth/logout', { method: 'POST' });
      setUser(null);
    } catch (error) {
      console.error('Logout error:', error);
    }
  }, []);

  const refreshToken = useCallback(async () => {
    try {
      const response = await fetch('/api/auth/refresh', { method: 'POST' });
      if (response.ok) {
        const { user } = await response.json();
        setUser(user);
      }
    } catch (error) {
      console.error('Token refresh error:', error);
    }
  }, []);

  const hasPermission = useCallback((permission: string): boolean => {
    if (!user) return false;
    // Implementation depends on your permission system
    return user.permissions?.includes(permission) || false;
  }, [user]);

  const hasRole = useCallback((role: string): boolean => {
    if (!user) return false;
    return user.roles?.some(r => r.name === role) || false;
  }, [user]);

  useEffect(() => {
    // Initialize auth state on mount
    const initAuth = async () => {
      try {
        const response = await fetch('/api/auth/me');
        if (response.ok) {
          const { user } = await response.json();
          setUser(user);
        }
      } catch (error) {
        console.error('Auth initialization error:', error);
      } finally {
        setLoading(false);
      }
    };

    initAuth();
  }, []);

  const value: AuthContextValue = {
    user,
    loading,
    error,
    isAuthenticated: !!user,
    login,
    logout,
    refreshToken,
    hasPermission,
    hasRole
  };

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
}
```

### Generic Query Hook (`src/hooks/data/use-query.ts`)

```typescript
import { useState, useEffect, useCallback, useRef } from 'react';

export interface QueryOptions<T> {
  queryKey: string[];
  queryFn: () => Promise<T>;
  enabled?: boolean;
  staleTime?: number;
  cacheTime?: number;
  refetchOnWindowFocus?: boolean;
  refetchInterval?: number;
  retry?: number;
  retryDelay?: (attempt: number) => number;
  onSuccess?: (data: T) => void;
  onError?: (error: Error) => void;
}

export interface QueryResult<T> {
  data: T | undefined;
  loading: boolean;
  error: Error | null;
  refetch: () => Promise<void>;
  isStale: boolean;
  isFetching: boolean;
}

// Simple in-memory cache
const queryCache = new Map<string, {
  data: any;
  timestamp: number;
  staleTime: number;
}>();

export function useQuery<T>(options: QueryOptions<T>): QueryResult<T> {
  const {
    queryKey,
    queryFn,
    enabled = true,
    staleTime = 5 * 60 * 1000, // 5 minutes
    cacheTime = 10 * 60 * 1000, // 10 minutes
    refetchOnWindowFocus = true,
    refetchInterval,
    retry = 3,
    retryDelay = (attempt) => Math.pow(2, attempt) * 1000,
    onSuccess,
    onError
  } = options;

  const [data, setData] = useState<T | undefined>(undefined);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  const [isFetching, setIsFetching] = useState(false);

  const cacheKey = JSON.stringify(queryKey);
  const abortControllerRef = useRef<AbortController | null>(null);
  const retryCountRef = useRef(0);

  const getCachedData = useCallback(() => {
    const cached = queryCache.get(cacheKey);
    if (!cached) return null;

    const isExpired = Date.now() - cached.timestamp > cacheTime;
    if (isExpired) {
      queryCache.delete(cacheKey);
      return null;
    }

    return cached;
  }, [cacheKey, cacheTime]);

  const isStale = useCallback(() => {
    const cached = getCachedData();
    if (!cached) return true;
    return Date.now() - cached.timestamp > cached.staleTime;
  }, [getCachedData]);

  const fetchData = useCallback(async () => {
    if (!enabled) return;

    // Cancel previous request
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }

    // Check cache first
    const cached = getCachedData();
    if (cached && !isStale()) {
      setData(cached.data);
      setError(null);
      return;
    }

    setIsFetching(true);
    if (!data) setLoading(true);

    abortControllerRef.current = new AbortController();

    try {
      const result = await queryFn();

      // Cache the result
      queryCache.set(cacheKey, {
        data: result,
        timestamp: Date.now(),
        staleTime
      });

      setData(result);
      setError(null);
      retryCountRef.current = 0;
      onSuccess?.(result);
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));

      if (error.name === 'AbortError') return;

      if (retryCountRef.current < retry) {
        retryCountRef.current++;
        const delay = retryDelay(retryCountRef.current);
        setTimeout(() => fetchData(), delay);
        return;
      }

      setError(error);
      onError?.(error);
    } finally {
      setLoading(false);
      setIsFetching(false);
    }
  }, [enabled, queryFn, getCachedData, isStale, data, cacheKey, staleTime, retry, retryDelay, onSuccess, onError]);

  // Initial fetch
  useEffect(() => {
    fetchData();
  }, [fetchData]);

  // Refetch interval
  useEffect(() => {
    if (!refetchInterval || !enabled) return;

    const interval = setInterval(fetchData, refetchInterval);
    return () => clearInterval(interval);
  }, [refetchInterval, enabled, fetchData]);

  // Refetch on window focus
  useEffect(() => {
    if (!refetchOnWindowFocus || !enabled) return;

    const handleFocus = () => {
      if (isStale()) {
        fetchData();
      }
    };

    window.addEventListener('focus', handleFocus);
    return () => window.removeEventListener('focus', handleFocus);
  }, [refetchOnWindowFocus, enabled, isStale, fetchData]);

  // Cleanup
  useEffect(() => {
    return () => {
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
      }
    };
  }, []);

  return {
    data,
    loading,
    error,
    refetch: fetchData,
    isStale: isStale(),
    isFetching
  };
}
```

## Feature-Specific Hooks

### Event Management Hook (`src/hooks/features/events/use-events.ts`)

```typescript
import { useMemo } from 'react';
import { useQuery } from '@/hooks/data/use-query';
import { usePagination } from '@/hooks/data/use-pagination';
import type { Event } from '@prisma/client';

export interface EventFilters {
  status?: string;
  categoryId?: string;
  startDate?: Date;
  endDate?: Date;
  search?: string;
  tags?: string[];
}

export interface UseEventsOptions {
  filters?: EventFilters;
  sort?: {
    field: string;
    order: 'asc' | 'desc';
  };
  enabled?: boolean;
}

export interface UseEventsResult {
  events: Event[];
  loading: boolean;
  error: Error | null;
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
    hasNext: boolean;
    hasPrev: boolean;
    goToPage: (page: number) => void;
    nextPage: () => void;
    prevPage: () => void;
  };
  filters: EventFilters;
  setFilters: (filters: EventFilters) => void;
  sort: { field: string; order: 'asc' | 'desc' };
  setSort: (field: string, order?: 'asc' | 'desc') => void;
  refetch: () => Promise<void>;
}

export function useEvents(options: UseEventsOptions = {}): UseEventsResult {
  const { filters = {}, sort = { field: 'startDate', order: 'desc' }, enabled = true } = options;

  const pagination = usePagination({ pageSize: 20 });

  // Build query parameters
  const queryParams = useMemo(() => {
    const params = new URLSearchParams({
      page: pagination.page.toString(),
      limit: pagination.limit.toString(),
      sortBy: sort.field,
      sortOrder: sort.order
    });

    Object.entries(filters).forEach(([key, value]) => {
      if (value !== undefined && value !== null && value !== '') {
        if (Array.isArray(value)) {
          value.forEach(v => params.append(key, v));
        } else if (value instanceof Date) {
          params.append(key, value.toISOString());
        } else {
          params.append(key, String(value));
        }
      }
    });

    return params.toString();
  }, [filters, sort, pagination.page, pagination.limit]);

  // Fetch events
  const {
    data: response,
    loading,
    error,
    refetch
  } = useQuery({
    queryKey: ['events', queryParams],
    queryFn: async () => {
      const response = await fetch(`/api/events?${queryParams}`);
      if (!response.ok) {
        throw new Error('Failed to fetch events');
      }
      return response.json();
    },
    enabled,
    staleTime: 2 * 60 * 1000, // 2 minutes
    onSuccess: (data) => {
      pagination.setTotal(data.pagination.total);
    }
  });

  const events = response?.data || [];

  const setFilters = useMemo(() => {
    return (newFilters: EventFilters) => {
      // Reset to first page when filters change
      pagination.goToPage(1);
      // Trigger refetch with new filters
      refetch();
    };
  }, [pagination, refetch]);

  const setSort = useMemo(() => {
    return (field: string, order: 'asc' | 'desc' = 'desc') => {
      // Sort change should trigger refetch
      refetch();
    };
  }, [refetch]);

  return {
    events,
    loading,
    error,
    pagination: {
      page: pagination.page,
      limit: pagination.limit,
      total: pagination.total,
      totalPages: pagination.totalPages,
      hasNext: pagination.hasNext,
      hasPrev: pagination.hasPrev,
      goToPage: pagination.goToPage,
      nextPage: pagination.nextPage,
      prevPage: pagination.prevPage
    },
    filters,
    setFilters,
    sort,
    setSort,
    refetch
  };
}
```

### Form Management Hook (`src/hooks/ui/use-form.ts`)

```typescript
import { useState, useCallback, useRef } from 'react';
import { z } from 'zod';

export interface FormField<T = any> {
  value: T;
  error: string | null;
  touched: boolean;
  dirty: boolean;
}

export interface FormState<T extends Record<string, any>> {
  fields: { [K in keyof T]: FormField<T[K]> };
  isValid: boolean;
  isDirty: boolean;
  isSubmitting: boolean;
  errors: Partial<Record<keyof T, string>>;
}

export interface UseFormOptions<T extends Record<string, any>> {
  initialValues: T;
  validationSchema?: z.ZodSchema<T>;
  validateOnChange?: boolean;
  validateOnBlur?: boolean;
  onSubmit?: (values: T) => Promise<void> | void;
}

export interface UseFormResult<T extends Record<string, any>> {
  values: T;
  errors: Partial<Record<keyof T, string>>;
  touched: Partial<Record<keyof T, boolean>>;
  isValid: boolean;
  isDirty: boolean;
  isSubmitting: boolean;
  setValue: <K extends keyof T>(field: K, value: T[K]) => void;
  setFieldError: <K extends keyof T>(field: K, error: string | null) => void;
  setFieldTouched: <K extends keyof T>(field: K, touched?: boolean) => void;
  validateField: <K extends keyof T>(field: K) => Promise<boolean>;
  validateForm: () => Promise<boolean>;
  resetForm: (values?: Partial<T>) => void;
  resetField: <K extends keyof T>(field: K) => void;
  handleSubmit: (e?: React.FormEvent) => Promise<void>;
  getFieldProps: <K extends keyof T>(field: K) => {
    value: T[K];
    onChange: (value: T[K]) => void;
    onBlur: () => void;
    error: string | null;
    touched: boolean;
  };
}

export function useForm<T extends Record<string, any>>(
  options: UseFormOptions<T>
): UseFormResult<T> {
  const {
    initialValues,
    validationSchema,
    validateOnChange = true,
    validateOnBlur = true,
    onSubmit
  } = options;

  // Form state
  const [values, setValues] = useState<T>(initialValues);
  const [errors, setErrors] = useState<Partial<Record<keyof T, string>>>({});
  const [touched, setTouched] = useState<Partial<Record<keyof T, boolean>>>({});
  const [isSubmitting, setIsSubmitting] = useState(false);

  const initialValuesRef = useRef(initialValues);

  // Computed properties
  const isValid = Object.keys(errors).length === 0;
  const isDirty = JSON.stringify(values) !== JSON.stringify(initialValuesRef.current);

  // Set field value
  const setValue = useCallback(<K extends keyof T>(field: K, value: T[K]) => {
    setValues(prev => ({ ...prev, [field]: value }));

    if (validateOnChange) {
      validateField(field);
    }
  }, [validateOnChange]);

  // Set field error
  const setFieldError = useCallback(<K extends keyof T>(field: K, error: string | null) => {
    setErrors(prev => {
      if (error === null) {
        const { [field]: _, ...rest } = prev;
        return rest;
      }
      return { ...prev, [field]: error };
    });
  }, []);

  // Set field touched
  const setFieldTouched = useCallback(<K extends keyof T>(
    field: K,
    touchedValue: boolean = true
  ) => {
    setTouched(prev => ({ ...prev, [field]: touchedValue }));

    if (touchedValue && validateOnBlur) {
      validateField(field);
    }
  }, [validateOnBlur]);

  // Validate single field
  const validateField = useCallback(async <K extends keyof T>(field: K): Promise<boolean> => {
    if (!validationSchema) return true;

    try {
      const fieldSchema = validationSchema.shape?.[field as string];
      if (fieldSchema) {
        await fieldSchema.parseAsync(values[field]);
        setFieldError(field, null);
        return true;
      }
    } catch (error) {
      if (error instanceof z.ZodError) {
        const fieldError = error.errors[0]?.message || 'Invalid value';
        setFieldError(field, fieldError);
        return false;
      }
    }

    return true;
  }, [validationSchema, values, setFieldError]);

  // Validate entire form
  const validateForm = useCallback(async (): Promise<boolean> => {
    if (!validationSchema) return true;

    try {
      await validationSchema.parseAsync(values);
      setErrors({});
      return true;
    } catch (error) {
      if (error instanceof z.ZodError) {
        const formErrors: Partial<Record<keyof T, string>> = {};
        error.errors.forEach(err => {
          const field = err.path[0] as keyof T;
          if (field) {
            formErrors[field] = err.message;
          }
        });
        setErrors(formErrors);
        return false;
      }
    }

    return false;
  }, [validationSchema, values]);

  // Reset form
  const resetForm = useCallback((newValues?: Partial<T>) => {
    const resetValues = { ...initialValues, ...newValues };
    setValues(resetValues);
    setErrors({});
    setTouched({});
    setIsSubmitting(false);
    initialValuesRef.current = resetValues;
  }, [initialValues]);

  // Reset single field
  const resetField = useCallback(<K extends keyof T>(field: K) => {
    setValues(prev => ({ ...prev, [field]: initialValues[field] }));
    setFieldError(field, null);
    setFieldTouched(field, false);
  }, [initialValues, setFieldError, setFieldTouched]);

  // Handle form submission
  const handleSubmit = useCallback(async (e?: React.FormEvent) => {
    e?.preventDefault();

    if (isSubmitting) return;

    setIsSubmitting(true);

    try {
      const isFormValid = await validateForm();

      if (isFormValid && onSubmit) {
        await onSubmit(values);
      }
    } catch (error) {
      console.error('Form submission error:', error);
    } finally {
      setIsSubmitting(false);
    }
  }, [isSubmitting, validateForm, onSubmit, values]);

  // Get field props for easy integration
  const getFieldProps = useCallback(<K extends keyof T>(field: K) => ({
    value: values[field],
    onChange: (value: T[K]) => setValue(field, value),
    onBlur: () => setFieldTouched(field, true),
    error: errors[field] || null,
    touched: touched[field] || false
  }), [values, errors, touched, setValue, setFieldTouched]);

  return {
    values,
    errors,
    touched,
    isValid,
    isDirty,
    isSubmitting,
    setValue,
    setFieldError,
    setFieldTouched,
    validateField,
    validateForm,
    resetForm,
    resetField,
    handleSubmit,
    getFieldProps
  };
}
```

## Utility Hooks

### Local Storage Hook (`src/hooks/utilities/use-local-storage.ts`)

```typescript
import { useState, useEffect, useCallback } from 'react';

export function useLocalStorage<T>(
  key: string,
  initialValue: T
): [T, (value: T | ((prev: T) => T)) => void, () => void] {
  // Get value from localStorage or use initial value
  const [storedValue, setStoredValue] = useState<T>(() => {
    if (typeof window === 'undefined') {
      return initialValue;
    }

    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(`Error reading localStorage key "${key}":`, error);
      return initialValue;
    }
  });

  // Update localStorage when state changes
  const setValue = useCallback((value: T | ((prev: T) => T)) => {
    try {
      const valueToStore = value instanceof Function ? value(storedValue) : value;
      setStoredValue(valueToStore);

      if (typeof window !== 'undefined') {
        window.localStorage.setItem(key, JSON.stringify(valueToStore));
      }
    } catch (error) {
      console.error(`Error setting localStorage key "${key}":`, error);
    }
  }, [key, storedValue]);

  // Remove item from localStorage
  const removeValue = useCallback(() => {
    try {
      setStoredValue(initialValue);
      if (typeof window !== 'undefined') {
        window.localStorage.removeItem(key);
      }
    } catch (error) {
      console.error(`Error removing localStorage key "${key}":`, error);
    }
  }, [key, initialValue]);

  // Listen for changes from other tabs/windows
  useEffect(() => {
    if (typeof window === 'undefined') return;

    const handleStorageChange = (e: StorageEvent) => {
      if (e.key === key && e.newValue !== null) {
        try {
          setStoredValue(JSON.parse(e.newValue));
        } catch (error) {
          console.error(`Error parsing localStorage value for key "${key}":`, error);
        }
      }
    };

    window.addEventListener('storage', handleStorageChange);
    return () => window.removeEventListener('storage', handleStorageChange);
  }, [key]);

  return [storedValue, setValue, removeValue];
}
```

### Debounce Hook (`src/hooks/utilities/use-debounce.ts`)

```typescript
import { useState, useEffect, useRef } from 'react';

export function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}

export function useDebouncedCallback<T extends (...args: any[]) => any>(
  callback: T,
  delay: number
): T {
  const callbackRef = useRef(callback);
  const timeoutRef = useRef<NodeJS.Timeout>();

  // Update callback ref when callback changes
  useEffect(() => {
    callbackRef.current = callback;
  }, [callback]);

  const debouncedCallback = useRef(
    ((...args: Parameters<T>) => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }

      timeoutRef.current = setTimeout(() => {
        callbackRef.current(...args);
      }, delay);
    }) as T
  );

  // Cleanup timeout on unmount
  useEffect(() => {
    return () => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
    };
  }, []);

  return debouncedCallback.current;
}
```

## Performance Hooks

### Memoization Hook (`src/hooks/performance/use-memo-deep.ts`)

```typescript
import { useRef, useMemo } from 'react';

// Deep equality check
function deepEqual(a: any, b: any): boolean {
  if (a === b) return true;

  if (a == null || b == null) return a === b;

  if (typeof a !== typeof b) return false;

  if (typeof a !== 'object') return a === b;

  if (Array.isArray(a) !== Array.isArray(b)) return false;

  if (Array.isArray(a)) {
    if (a.length !== b.length) return false;
    for (let i = 0; i < a.length; i++) {
      if (!deepEqual(a[i], b[i])) return false;
    }
    return true;
  }

  const keysA = Object.keys(a);
  const keysB = Object.keys(b);

  if (keysA.length !== keysB.length) return false;

  for (let key of keysA) {
    if (!keysB.includes(key)) return false;
    if (!deepEqual(a[key], b[key])) return false;
  }

  return true;
}

export function useMemoDeep<T>(factory: () => T, deps: React.DependencyList): T {
  const ref = useRef<{ deps: React.DependencyList; value: T }>();

  return useMemo(() => {
    if (!ref.current || !deepEqual(ref.current.deps, deps)) {
      ref.current = {
        deps,
        value: factory()
      };
    }
    return ref.current.value;
  }, deps);
}
```

## Hook Testing Patterns

### Hook Testing Utilities (`src/hooks/__tests__/test-utils.ts`)

```typescript
import { renderHook, RenderHookResult } from '@testing-library/react';
import { act } from '@testing-library/react';

// Wrapper for testing hooks with providers
export function renderHookWithProviders<TProps, TResult>(
  hook: (props: TProps) => TResult,
  options?: {
    initialProps?: TProps;
    wrapper?: React.ComponentType;
  }
): RenderHookResult<TResult, TProps> {
  return renderHook(hook, options);
}

// Async hook testing utility
export async function actAsync(fn: () => Promise<any>): Promise<void> {
  await act(async () => {
    await fn();
  });
}

// Mock localStorage for testing
export function mockLocalStorage() {
  const storage: Record<string, string> = {};

  const mockLocalStorage = {
    getItem: jest.fn((key: string) => storage[key] || null),
    setItem: jest.fn((key: string, value: string) => {
      storage[key] = value;
    }),
    removeItem: jest.fn((key: string) => {
      delete storage[key];
    }),
    clear: jest.fn(() => {
      Object.keys(storage).forEach(key => delete storage[key]);
    }),
    length: 0,
    key: jest.fn()
  };

  Object.defineProperty(window, 'localStorage', {
    value: mockLocalStorage,
    writable: true
  });

  return mockLocalStorage;
}
```

### Hook Test Example

```typescript
// __tests__/use-events.test.ts
import { renderHook, waitFor } from '@testing-library/react';
import { useEvents } from '@/hooks/features/events/use-events';
import { mockLocalStorage } from './test-utils';

// Mock fetch
global.fetch = jest.fn();

describe('useEvents', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    mockLocalStorage();
  });

  it('should fetch events on mount', async () => {
    const mockEvents = [
      { id: '1', title: 'Event 1', startDate: new Date() },
      { id: '2', title: 'Event 2', startDate: new Date() }
    ];

    (fetch as jest.Mock).mockResolvedValue({
      ok: true,
      json: async () => ({
        data: mockEvents,
        pagination: { total: 2, page: 1, limit: 20 }
      })
    });

    const { result } = renderHook(() => useEvents());

    expect(result.current.loading).toBe(true);

    await waitFor(() => {
      expect(result.current.loading).toBe(false);
    });

    expect(result.current.events).toEqual(mockEvents);
    expect(result.current.error).toBeNull();
  });

  it('should handle fetch errors', async () => {
    (fetch as jest.Mock).mockRejectedValue(new Error('Fetch failed'));

    const { result } = renderHook(() => useEvents());

    await waitFor(() => {
      expect(result.current.loading).toBe(false);
    });

    expect(result.current.error).toEqual(new Error('Fetch failed'));
    expect(result.current.events).toEqual([]);
  });
});
```

## Documentation Requirements

### Hook Documentation

````typescript
/**
 * Hook for managing event data with filtering, sorting, and pagination.
 *
 * @param options - Configuration options for the hook
 * @returns Object containing events data, loading state, and control functions
 *
 * @example
 * ```tsx
 * function EventList() {
 *   const { events, loading, setFilters } = useEvents({
 *     filters: { status: 'published' },
 *     sort: { field: 'startDate', order: 'asc' }
 *   });
 *
 *   if (loading) return <Loading />;
 *
 *   return (
 *     <div>
 *       {events.map(event => (
 *         <EventCard key={event.id} event={event} />
 *       ))}
 *     </div>
 *   );
 * }
 * ```
 */
export function useEvents(options: UseEventsOptions = {}): UseEventsResult {
  // Implementation
}
````

This comprehensive hook organization provides a solid foundation for building maintainable, reusable, and well-tested React hooks in the GameOne application.
